# Вычислить число c заданной точностью d
# Пример:
# при d = 0.001, π = 3.141    10^-1 ≤ d ≤10^-10

# Предположил, что все-таки в задаче требовалось найти число π с заданной точностью, которой выбирает пользователь
# Для расчета π использовал формулу Лейбница (бесконечный ряд 4 * ((-1) ** i / (2 * i + 1)))
# Точность рассматривал, как модуль изменения разности последующего значения функции с текущим. Оформил циклом while с условием:
# Если модуль разницы меньше заданной точности цикл завершаю
# Число π рассчитывал как среднюю арифметическую двух последних значений цикла. Но значение π как в задании не удается получить.

#d = 10 ** (-3)
from math import fabs
d = float(input('Введите число с заданной точностью расчета числа π: '))

while d > 10 ** (-1) or d < 10 ** (-10):
    d = float(input('Введите число с заданной точностью расчета числа π: '))


top_pi = 0
bottom_pi = 0

i = 0
top_pi = 4 * ((-1) ** i / (2 * i + 1))

i = 1
while fabs(bottom_pi - top_pi) >= d:
    top_pi = top_pi + 4 * ((-1) ** i / (2 * i + 1))
    bottom_pi = top_pi + (4 * ((-1) ** i / (2 * i + 1)))
    i += 1
    print('π0 =', top_pi, '   π1 =', bottom_pi, '   Модуль разницы =',
          fabs(bottom_pi - top_pi), '   Необходимая точность =', d)

pi = (bottom_pi + top_pi) / 2

print('π =', pi)

# если все-таки округляем
counter = 0
while d != 1:
    d = d * 10
    counter += 1

print('π =', round(pi, counter))


# # Другой вариант
# # π = 4/1 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11 + 4/13 - 4/15 + ...
# # π = 4/x - 4/(x+2) + 4/(x+3)- ...

# d = 10**(-3)
# sum = 0
# x = 1
# sign = 1

# while True:
#     a = 4 / x
#     sum += sign * a
#     if a < d:
#         break
#     x += 2
#     sign *= -1

# print("π =", sum)
